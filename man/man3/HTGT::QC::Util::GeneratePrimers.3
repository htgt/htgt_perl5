.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTGT::QC::Util::GeneratePrimers 3"
.TH HTGT::QC::Util::GeneratePrimers 3 "2017-02-22" "perl v5.14.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTGT::QC::Util::GeneratePrimers
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Generate a primer pair for a given target.
Input:
    \- Bio::Seq object with the target sequence
    \- Coordinates of sequence in Bio::Seq object
    \- Primer3 parameters
    \- optional genomic specificifty check options
.SS "primer3_target_string"
.IX Subsection "primer3_target_string"
String which tells Primer3 what region the primers must flank.
It is in the form: <start>,<length>
<start> is the index of the first base of the target region.
<length> is the the length of the target.
.SS "primer_product_size_range"
.IX Subsection "primer_product_size_range"
String which tells Primer3 what how big the product from the primers should be.
It is in the form: <x>\-<y>
<x> is the minimum size
<y> is the maximum size
.PP
You can specify a list of ranges ( e.g. 100\-200 400\-500 ). If this is done Primer3 tries
to make produces in the first size range, only expanding to other ranges if it can't
find anything.
.SS "generate_primers"
.IX Subsection "generate_primers"
Find primers for target region specified inside sequence.
.SS "run_primer3"
.IX Subsection "run_primer3"
Run Primer3 using DesignCreate::Util::Primer3 module.
.SS "parse_primer3_results"
.IX Subsection "parse_primer3_results"
Extract the required information from the Bio::Tools::Primer3Redux::Result object
It outputs information about each primer pair.
.SS "parse_primer"
.IX Subsection "parse_primer"
Parse output required data from the Bio::Tools::Primer3Redux::Primer objects
( basically a Bio::SeqFeature::Generic object plus few other methods ).
Also add other calulated data about primer.
.SS "calculate_oligo_coords_and_sequence"
.IX Subsection "calculate_oligo_coords_and_sequence"
Primer3 takes in sequence 5' to 3' so we need to work out the primer
sequence and coordiantes if the target was on the +ve or \-ve strand.
.SS "filter_primers"
.IX Subsection "filter_primers"
Filter out primers that do not meet the genomic specificity criteria.
We have option of only picking forward / reverse primer so check if primer
exists first.
.SS "run_bwa"
.IX Subsection "run_bwa"
Run bwa aln against all the candidate primers.
.SS "define_bwa_query_file"
.IX Subsection "define_bwa_query_file"
Generate a fasta file containing all the candidate primers to run against bwa aln.
.SS "check_oligo_specificity"
.IX Subsection "check_oligo_specificity"
Filter out oligos that have mulitple hits against the reference genome.
A unique alignment ( score of 30+ ) gives a true return value. This should be
the case where bwa finds one unique alignment for the oligo, which should be the
original position of the oligo, though this is not checked.
.PP
If the oligo can not be mapped against the genome we return false.
.PP
In any other case we count the number of hits, which is 90%+ similarity or up to 2 mismatches.
By default any more than 1 hit will return false, the user can loosen this criteria though
and allow up to n hits ( num_genomic_hits attribute ).
