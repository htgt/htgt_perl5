.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Test::Mock::LWP::Dispatch 3"
.TH Test::Mock::LWP::Dispatch 3 "2013-05-28" "perl v5.14.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Test::Mock::LWP::Dispatch \- mocks LWP::UserAgent and dispatches your requests/responses
.SH "VERSION"
.IX Header "VERSION"
version 0.06
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  # in your *.t
\&  use Test::Mock::LWP::Dispatch;
\&  use HTTP::Response;
\&
\&  # global mappings for requests and responses for LWP::UserAgent
\&  $mock_ua\->map(\*(Aqhttp://example.com\*(Aq, HTTP::Response\->new(...));
\&  # or
\&  $mock_ua\->map(qr!^http://example.com/page!, sub { my $request = shift;
\&                                                    # ... create $response
\&                                                    return $response; });
\&
\&  # or make local mappings
\&  my $ua = LWP::UserAgent\->new;
\&  $ua\->map(...);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module intends for testing a code that heavily uses LWP::UserAgent.
.PP
Assume that function you want to test makes three different request to the server
and expects to get some content from the server. To test this function you should
setup request/response mappings for mocked UserAgent and test it.
.PP
For doing something with mappings, here are methods \f(CW\*(C`map\*(C'\fR, \f(CW\*(C`unmap\*(C'\fR and \f(CW\*(C`unmap_all\*(C'\fR. For controlling context of these mappings (is it applies for all created in your
code LWP::UserAgent's or only to one specific?) you should call these functions
for exported \f(CW$mock_ua\fR object (global mapping) or for newly created LWP::UserAgent (local mappings).
.PP
See also on Test::Mock::LWP, it provides mocked \s-1LWP\s0 objects for you, so probably
you can solve your problems with this module too.
.SH "METHODS"
.IX Header "METHODS"
.IP "simple_request($req)" 4
.IX Item "simple_request($req)"
This is only method of LWP::UserAgent that mocked. When you make \f(CW$ua\fR\->get(...)
or \f(CW$ua\fR\->head(...) or just \fIget()\fR from LWP::Simple, at some point calls
\&\f(CW\*(C`simple_request()\*(C'\fR method. So for controlling responses to your requests it is
only method needed to mock.
.Sp
In this module \f(CW\*(C`simple_request()\*(C'\fR loops through your local and global mappings
(in this order) and returns response on a first matched mapping. If no matched
\&\f(CW\*(C`simple_request()\*(C'\fR returns HTTP::Response with 404 code.
.Sp
Be accurate: method loops through mappings in order of adding these mappings.
.ie n .IP "map($req_descr, $resp_descr)" 4
.el .IP "map($req_descr, \f(CW$resp_descr\fR)" 4
.IX Item "map($req_descr, $resp_descr)"
Using this method you can say what response should be on what request.
.Sp
If you call this method for exported \f(CW$mock_ua\fR it will make global mappings
applied for all newly created LWP::UserAgent's. If you call this method for
separate LWP::UserAgent you created, then this mapping will work only for
this object.
.Sp
Request description \f(CW$req_descr\fR can be:
.RS 4
.IP "string" 4
.IX Item "string"
Uri for exact matching with incoming request uri in \f(CW\*(C`request()\*(C'\fR.
.IP "regexp" 4
.IX Item "regexp"
Regexp on what incoming request uri will match.
.IP "code" 4
.IX Item "code"
You can pass arbitrary coderef, that takes incoming HTTP::Request and returns
true if this request matched.
.IP "HTTP::Request object" 4
.IX Item "HTTP::Request object"
If you pass such object, then request will compare that incoming request
exactly the same that you passed in \f(CW\*(C`map()\*(C'\fR (this means, that all query
parameters, all headers and so on must be identical).
.RE
.RS 4
.Sp
Response description \f(CW$resp_descr\fR, that will be returned if incoming request
to \f(CW\*(C`request()\*(C'\fR matches with \f(CW$req_descr\fR, can be:
.IP "HTTP::Response object" 4
.IX Item "HTTP::Response object"
Ready to return HTTP::Response object.
.IP "code" 4
.IX Item "code"
Arbitrary coderef, that takes incoming request as parameter and returns
HTTP::Response object.
.RE
.RS 4
.Sp
Method returns index of your mapping. You can use it in \f(CW\*(C`unmap\*(C'\fR.
.RE
.IP "unmap($map_index)" 4
.IX Item "unmap($map_index)"
Deletes some mapping by index.
.IP "unmap_all" 4
.IX Item "unmap_all"
Deletes all mappings.
.SH "SWITCHES"
.IX Header "SWITCHES"
.SS "\s-1DEFAULT_REQUEST_HEADERS\s0"
.IX Subsection "DEFAULT_REQUEST_HEADERS"
LWP::UserAgent sets default headers for requests by calling
LWP::UserAgent\->\fIprepare_request()\fR.
.PP
Previous versions (<= 0.05) of Test:Mock::LWP::Dispatch didn't intercept this call
in overridden \f(CW\*(C`simple_request()\*(C'\fR.
.PP
Now Test::Mock::LWP::Dispatch does it by default.
.PP
If for some reason you want to get back previous behaviour of the module,
set the following variable off:
.PP
\&\f(CW$Test::Mock::LWP::Dispatch::DEFAULT_REQUEST_HEADERS\fR = 0;
.SH "MISCELLANEOUS"
.IX Header "MISCELLANEOUS"
This mock object doesn't call \f(CW\*(C`fake_new()\*(C'\fR. So when you prepare response using
coderef, you can be sure, that \*(L"User-Agent\*(R" header will be untouched and so on.
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
Mike Doherty
.PP
Andreas Ko\*:nig
.PP
Ash Berlin
.PP
Joe Papperello
.SH "SEE ALSO"
.IX Header "SEE ALSO"
<http://github.com/tadam/Test\-Mock\-LWP\-Dispatch>
.PP
Test::Mock::LWP
.PP
LWP::UserAgent
.SH "AUTHOR"
.IX Header "AUTHOR"
Yury Zavarin <yury.zavarin@gmail.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2013 by Yury Zavarin.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 284:" 4
.IX Item "Around line 284:"
Non-ASCII character seen before =encoding in 'Ko\*:nig'. Assuming \s-1UTF\-8\s0
