.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTGT::QC::Util::GeneratePrimersAttempts 3"
.TH HTGT::QC::Util::GeneratePrimersAttempts 3 "2017-02-22" "perl v5.14.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTGT::QC::Util::GeneratePrimersAttempts
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Wrapper around HTGT::QC::Util::GeneratePrimers
If initial generation of primers fails this module will automatically try again
to generate the primers by expanding the search region for the primers.
.SS "sequence_regions"
.IX Subsection "sequence_regions"
optional array of genomic coordinates for regions of interest.
.PP
sequence_included_region:
Tells Primer3 which regions to pick primers in.
.PP
sequence_excluded_region:
Tells Primer3 which regions to avoid picking primers in.
.PP
Each element of list is a hashref in the form:
{ start => 111, end => 222 }
.SS "find_primers"
.IX Subsection "find_primers"
Attempt to generate primers for target, if this fails initially try again
with a increased search area for the primers.
.SS "generate_primer_attempt"
.IX Subsection "generate_primer_attempt"
Run the HTGT::QC::Util::GeneratePrimers modules.
Grab target sequence slice from EnsEMBL.
.SS "setup_new_attempt"
.IX Subsection "setup_new_attempt"
Expand primer search region after failing to find primers.
If we have a forward primer ( so are only looking for a reverse primer )
we do not expand the five prime region.
.PP
Return true if we are okay to setup new attempt, otherwise false.
.SS "generate_target_string"
.IX Subsection "generate_target_string"
Generate string which tells Primer3 what region the primers must flank.
It is in the form: <start>,<length>
<start> is the index of the first base of the target.
<length> is the the length of the target.
.PP
This is the \s-1SEQUENCE_TARGET\s0 parameter sent into Primer3.
.SS "generate_primer_product_size_range"
.IX Subsection "generate_primer_product_size_range"
Generate string which tells Primer3 what how big the product from the primers should be.
It is in the form: <x>\-<y>
<x> is the minimum size
<y> is the maximum size
.PP
You can specify a list of ranges ( e.g. 100\-200 400\-500 ). If this is done Primer3 tries
to make products in the first size range, only expanding the the other ranges if it can't
find anything.
We use this property when expanding the search region, favoring products that would be
produced by primers found in the expanded region.
.PP
If we have a forward primer specified then the product is always anchored to that primer
so the calculations for the size range is different.
.PP
If we have user specified value ( primer_product_size_range attribute ) always use this.
.PP
This is the \s-1PRIMER_PRODUCT_SIZE_RANGE\s0 parameter sent into Primer3.
.SS "build_region_slice"
.IX Subsection "build_region_slice"
Build a Bio::EnsEMBL::Slice for a given target regions
.SS "process_avoid_product_size"
.IX Subsection "process_avoid_product_size"
If user has set a certain size of product to avoid recalculate
the product size range values to avoid this size.
.SS "generate_sequence_region"
.IX Subsection "generate_sequence_region"
Generate a list of regions to pass to Primer3:
It is in the form of a space seperated list:
<start>,<length> <start>,<length> ...
.PP
Must work out coordiantes relative to the sequence we send to Primer3.
.PP
Used for following Primer parameters:
\&\s-1SEQUENCE_EXCLUDED_REGION:\s0 area to avoid searching for primers
\&\s-1SEQUENCE_INCLUDED_REGION:\s0 area to search for primers
