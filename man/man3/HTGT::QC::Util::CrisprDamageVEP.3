.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTGT::QC::Util::CrisprDamageVEP 3"
.TH HTGT::QC::Util::CrisprDamageVEP 3 "2017-02-22" "perl v5.14.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTGT::QC::Util::CrisprDamageVEP
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Identify damage caused by crispr(s) on the second allele.
Compare wildtype genomic sequence of area around crispr(s) target site with the sequence
from primer reads that flank this target site.
Try to predict the effect of the damage using Ensemble's Varient Effect Predictor (\s-1VEP\s0) software.
.PP
Hopefully can send provide a \s-1SAM\s0 alignment file for the reads we are interested in,
this should mean we run bwa mem once and split up the \s-1SAM\s0 file to send into this module.
Otherwise we need to run bwa mem to generate the \s-1SAM\s0 file.
.SS "analyse"
.IX Subsection "analyse"
Run the analysis
.SS "sam_to_bam"
.IX Subsection "sam_to_bam"
Convert sam file to a sorted bam file, ready for input
into mpileup. Also filter out secondary alignments.
.PP
The log file may contain a warning about \s-1EOF\s0 marker is absent,
this is a known bug and the warning can be ignored.
.SS "remove_reads_not_overlapping_target"
.IX Subsection "remove_reads_not_overlapping_target"
Index the bam file then filter out alignments that do not hit the target region.
We use samtools view with the target region specified to do this.
.SS "run_mpileup"
.IX Subsection "run_mpileup"
Run mpileup, input is sorted bam file.
We want pileup and bcf output.
.SS "parse_pileup_file"
.IX Subsection "parse_pileup_file"
Parse the pileup file, generate following information:
* Read alignment strings to show to user.
* Genome start and end coordinates for reference sequence string.
* Hash of insertion sequences keyed on insert position ( relative to ref string, not genome ).
.SS "variant_calling"
.IX Subsection "variant_calling"
Use bcftools call to find the SNP/Indels
.SS "target_region_vcf_file"
.IX Subsection "target_region_vcf_file"
Produce a vcf file which only looks at the target region we are interested in.
Any variants not overlapping the target region will be filtered out.
.SS "merge_variants"
.IX Subsection "merge_variants"
Attempt to merge all the variants from the target region vcf file into one variant.
This is hack that lets us run the resultant merged vcf file through \s-1VEP\s0
which will then produce one mutant protein sequence ( instead of multiple sequences
for each variant ). The output from \s-1VEP\s0 when doing this is not optimal.
.PP
We should find another way to produce the reference and mutant protein sequences and
stop merging the variants.
.SS "call_variant_type"
.IX Subsection "call_variant_type"
Attempt to make a overall call of the variant type to aid in human analysis of results.
Can only do this when variant is supported by 2 reads.
Use the MergeVariantsVCF object to get the parsed variants details from the vcf file.
.SS "reads_do_not_cover_target_region"
.IX Subsection "reads_do_not_cover_target_region"
A hacky way to check if both the forward and reverse read completely cover the target region.
I only do it this way because I have already drawn up the alignment in the DrawPileupAlignment
object. ( Really should use the \s-1SAM\s0 file to check the extent of the read alignment )
.SS "variant_effect_predictor"
.IX Subsection "variant_effect_predictor"
Run the Ensembl variant_effect_predictor.pl script and store the output.
.SS "align_reads"
.IX Subsection "align_reads"
Align the read(s) against the reference genome
using bwa mem
.SS "bwa_mem"
.IX Subsection "bwa_mem"
Run bwa mem, return the output sam file
.SS "no_target_region_variants"
.IX Subsection "no_target_region_variants"
Check vcf file for target region to see if we have any variants
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 140:" 4
.IX Item "Around line 140:"
Unknown directive: =read2
