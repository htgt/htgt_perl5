.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTGT::QC::Util::DrawPileupAlignment 3"
.TH HTGT::QC::Util::DrawPileupAlignment 3 "2017-02-22" "perl v5.14.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTGT::QC::Util::DrawPileupAlignment
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Take a pileup file generated from very specific input and build up the aligned sequence
to display. Used to create aligned sequences of primer pair reads that cover area of potential
crispr damage.
.PP
The pileup file must consist of 2 reads, one forward and one reverse, that overlap the same area.
.SS "calculate_pileup_alignment"
.IX Subsection "calculate_pileup_alignment"
Calculate the aligned sequences for the reads against the genome so we can build a
simple diagram that shows the reads to show the users.
.PP
Pilup is a tab delimited file, following data stored in each column:
0 = chromosome
1 = position ( 1 based )
2 = ref base
3 = read depth
4 = read bases
5 = base qualities
.PP
The read bases string can be interpreted as follows:
\&. = match to reference on forward strand
, = match to reference on reverse strand
\&\s-1AGCTN\s0 = mismatch on forward strand
agctn = mismatch on reverse strand
^ = start of read
$ = end of read
+4ACGT = insertion of sequence, 4 bases \s-1ACGT
\&\-4CACC\s0 = deletion of sequence, 4 bases \s-1CACC\s0
.SS "create_output_files"
.IX Subsection "create_output_files"
Create output files holding data required to build alignment text.
.SS "calculate_read_positions"
.IX Subsection "calculate_read_positions"
Work out the positions of the forward and reverse reads in the pileup file.
.SS "split_reads"
.IX Subsection "split_reads"
Split the reads string from the pileup output into a array of
characters, one for each read, which indicates what is present at
this position for each read.
.PP
Strip out the special character sequences from the string and parse them:
Insertions: +[0\-9]+[ACTGNactgn]+
    e.g +4ACTT
    Store in insertions hash.
.PP
Deletions: \-[0\-9]+[ACTGNactgn]+
    e.g. \-2gg
    Just remove from string.
.PP
Start of read: ^.
    e.g. ^]
    Mark appropriate read has active.
.PP
End of read: $
    Mark appropriate read as inactive.
.SS "build_sequences"
.IX Subsection "build_sequences"
Add appropriate characters to each read sequence string.
.SS "build_single_sequence"
.IX Subsection "build_single_sequence"
When only 1 read aligning to reference at given position need to add a space
character to the other inactive read.
.SS "calculate_base"
.IX Subsection "calculate_base"
Calculate the character to be appended to the sequence string.
.SS "parse_insertions"
.IX Subsection "parse_insertions"
Go through the insertion strings and insert them into the read and reference
sequences.
.SS "add_insertion"
.IX Subsection "add_insertion"
Push the insert sequence into the named sequence string.
.SS "truncated_sequence"
.IX Subsection "truncated_sequence"
Create a truncated version of each sequence that covers the target region.
.SS "grab_genomic_seq"
.IX Subsection "grab_genomic_seq"
Grab genomic sequence from specified coordinates.
